---
layout: post
title: 《深入理解jvm》读书笔记之——GC算法
category: 技术
tags: [tech]
keywords: jvm,classloader,gc,arithmetic
description: 《深入理解jvm》读书笔记之——GC算法
---


## 1、垃圾收集算法   

### 1.1、标记清除法    

标记清除就像他的名字一样，他分为两个阶段：    
- 第一个阶段就是标记出所有需要回收的对象   
- 第二个阶段就是进行垃圾回收，也就是清除掉我们第一阶段标记的对象    

我们可以看一下下面的这个图    
![5206EC59-076B-45D3-9DE5-C0F1489C6417.png](http://upload-images.jianshu.io/upload_images/584578-979eef779f9d0bfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)     

这就是一个标记清除的过程，很简单。    
这里面有一个需要关注的点：我们的第一个阶段标记，他是怎么进行的标记呢？    

对于这种标记的方式，其实也是有两种方式的：   
> 1. 引用计数法         
> 2. 可达性分析算法      

**note:**关于这两种方式的具体，我们可以看一下我上一篇文章的总结[《深入理解jvm》读书笔记之——判断对象存活的方法](http://www.jsondream.com/2016/12/01/jvm-class-load-object-is-live.html)     

那么我说一下，对于标记清除而言，他没有使用引用计数法，而是使用了gc root的标记方式.大家思考一下为什么？    
是这样的，引用计数虽然是一个很高效简单的方式，但是对于循环引用的对象，他是很难去判断的.    
假如内存中有2个对象，a和b，其实这时候只有a中有b，b中有a，但是整个jvm中没人要使用他们了，但是这种情况下，a和b的计数器还是1，所以就不会被标记，也就不会被gc掉.     

### 1.2、复制算法    

我们先思考一下,标记清楚是完美的吗?     
很显然不是,他的弊端在哪里?   
> **Q:**一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。   

所以我们这时候要讲一下***复制算法***了     
> 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。


![4109078B-4CF8-46E7-8705-82E507501641.png](http://upload-images.jianshu.io/upload_images/584578-f772cc00c97d3bf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)    

我们看一下这个图,这就是我们整个复制算法的过程，然后针对Hotspot的年轻代而言，也是基于这种算法来做的，这种算法的好处我上面也说了，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。    

#### 复制算法的弊端   
但是我们继续思考一下，这种算法是否有弊端，相信大家一眼就看出来。     
> 制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况    

所以.我们的hotspot虚拟机中的老年代并没有使用复制的算法,那么他使用的是啥呢？标记-整理算法     

### 1.3、标记-整理算法    

标记整理这种算法和标记清除有点类似,第一个阶段也是先标记,标记也是用的我们上面的gc root链的可达性分析算法.然后我们和标记清除不同的是第二部,这种算法让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存    

![EC42CD70-56C6-48EE-9C52-E35223AD1E3D.png](http://upload-images.jianshu.io/upload_images/584578-e49e7b572f6c20e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)     

大家可以看这个图,就是标记整理的算法的过程,那么对于这个算法,和标记清除的缺点是一样的,他虽然解决了空间的问题，但是对于标记这个阶段还是不够高效.那么究竟使用哪种算法最合适呢?那么就引入了我们的第四中算法:
分代.     

### 1.4、分代算法     

其实分代很简单，就是hotspot虚拟机讲整个jvm整个内存区域分为老年代，年轻带，永久代。根据不同的地方，不同的特性采用不同的算法来进行gc，这就是我们分代算法的实现。