---
layout: post
title: 线程池的原理以及java的线程池框架
category: 技术
tags: [tech]
keywords: threadfactory
description: threadfactory implement
---



## 什么是线程池？   

提供一组线程资源用来复用线程资源的一个池子      

## 为什么要用线程池？     

线程的资源是有限的，当处理一组业务的时候，我们需要不断的创建和销毁线程，大多数情况下，我们需要反复的进行大量的创建和销毁工作，这个动作对于服务器而言，也是很浪费的一种情况，这时候我们可以利用线程池来复用这一部分已经创建过的线程资源，避免不断的创建和销毁的动作。    

## 线程池的原理    

创建好固定数量的线程，吧线程先存下来，有任务提交的时候，把资源放到等待队列中，等待线程池中的任务队列不断的去消费处理这个队列中的任务    

## java的线程池原理    

有5个核心的属性：最大线程数量，核心线程数量，等待队列，任务队列，拒绝策略

它的执行流程是这样的：

1. 工作者workers数量低于核心工作者数corePoolSize时会优先创建一个工作者worker处理job，处理成功则返回。
2. 工作者workers数量高于核心工作者数时会优先把job放入到待处理队列，放入队列成功时处理结束。
3. 步骤2中入队失败会识别工作者数是否还小于最大工作者数maximumPoolsize，小于的话也会新创建一个工作者worker处理job。
4. 执行拒绝策略

## java的线程池框架Executor    

Executor里提供了4种类型的线程池：

#### newCachedThreadPool    

- 缓存型池子，先查看池中有没有以前建立的线程，如果有，就 reuse.如果没有，就建一个新的线程加入池中    
- 缓存型池子通常用于执行一些生存期很短的异步型任务    
 因此在一些面向连接的daemon型SERVER中用得不多。但对于生存期短的异步任务，它是Executor的首选。   
- 能reuse的线程，必须是timeout IDLE内的池中线程，缺省     timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。    
  
> 注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。    

#### newFixedThreadPool   

- newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程   
- 其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子   
- 和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的），所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器   
- 从方法的源代码看，cache池和fixed 池调用的是同一个底层 池，只不过参数不同:fixed池线程数固定，并且是0秒IDLE（无IDLE）,cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE      

#### newScheduledThreadPool    

- 调度型线程池    
- 这个池子里的线程可以按schedule依次delay执行，或周期执行    

#### SingleThreadExecutor    

- 单例线程，任意时间池中只能有一个线程   
- 用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE）    

## 线程池调优      

一般来讲对于一个线程池没有固定的合适的参数，只有通过不断的去调整优化参数，找出最适合自己业务的参数才是最好的调优方式，但是通常来讲，线程池的初始化参数设置是有一定的公式可以借鉴的，在开始业务不是足够膨胀的时候，我们可以通过以下的公式来计算出自己的核心参数的设置。      

首先我们要确认业务类型，不同的业务有不同的计算公式：     

- CPU密集型任务配置尽可能少的线程数量：cpu+1    
- IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。     
- 混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。  

